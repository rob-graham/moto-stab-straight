function results = eigen_scan(P, mats, speeds)
%EIGEN_SCAN  Sweep forward speed and classify modal behaviour.
%   RESULTS = EIGEN_SCAN(P, MATS, SPEEDS) evaluates the linearised
%   straight-running dynamics for the forward speeds specified in SPEEDS.
%   The matrices in MATS are generated by BUILD_MATRICES. The function
%   returns a struct containing eigenvalues, eigenvectors, natural
%   frequencies, damping ratios, and modal classification (wobble, weave,
%   capsize, and a fourth heavily damped caster mode).
%
%   If SPEEDS is omitted an evenly spaced vector spanning P.speed_range is
%   used.

arguments
    P struct
    mats struct
    speeds double = linspace(P.speed_range(1), P.speed_range(2), 80)
end

nV = numel(speeds);
lam_all = complex(zeros(nV, 4));
vec_all = cell(nV, 1);
mode_order = {'wobble', 'weave', 'capsize', 'caster'};
mode_vals = struct();
mode_freq = struct();
mode_zeta = struct();
for lbl = mode_order
    mode_vals.(lbl{1}) = complex(zeros(nV, 1));
    mode_freq.(lbl{1}) = nan(nV, 1);
    mode_zeta.(lbl{1}) = nan(nV, 1);
end

for k = 1:nV
    v = speeds(k);
    M = mats.M;
    B = v * mats.C1 + mats.D;
    K = P.g * mats.K0 + v^2 * mats.K2;
    A = [zeros(2), eye(2); -M\K, -M\B];

    [V, D] = eig(A);
    lam = diag(D);
    vec_all{k} = V;
    lam_sorted = assign_modes(lam);

    lam_all(k, :) = lam_sorted.';
    for idx = 1:numel(mode_order)
        name = mode_order{idx};
        val = lam_sorted(idx);
        mode_vals.(name)(k) = val;
        wn = abs(imag(val));
        if wn > 1e-6
            mode_freq.(name)(k) = wn / (2*pi);
            mode_zeta.(name)(k) = -real(val) / sqrt(real(val)^2 + imag(val)^2);
        else
            mode_freq.(name)(k) = 0;
            if abs(real(val)) > 1e-9
                mode_zeta.(name)(k) = sign(-real(val));
            else
                mode_zeta.(name)(k) = 0;
            end
        end
    end
end

results = struct();
results.speeds = speeds(:);
results.eigvals = lam_all;
results.eigvecs = vec_all;
results.mode_order = mode_order;
results.modes = mode_vals;
results.frequency_hz = mode_freq;
results.damping_ratio = mode_zeta;
end

function lam_sorted = assign_modes(lam)
%ASSIGN_MODES  Heuristic modal classification for motorcycle dynamics.

% Separate eigenvalues into complex pairs and real roots
imag_parts = imag(lam);
real_parts = real(lam);

complex_idx = find(imag_parts > 1e-7);
real_idx = find(abs(imag_parts) <= 1e-7);
assigned_idx = [];

% Complex pairs: highest frequency -> wobble, next -> weave
if isempty(complex_idx)
    wobble = NaN;
    weave = NaN;
else
    [~, sort_idx] = sort(abs(imag_parts(complex_idx)), 'descend');
    complex_idx = complex_idx(sort_idx);
    wobble = lam(complex_idx(1));
    assigned_idx(end+1) = complex_idx(1); %#ok<AGROW>
    if numel(complex_idx) > 1
        weave = lam(complex_idx(end));
        assigned_idx(end+1) = complex_idx(end); %#ok<AGROW>
    else
        weave = NaN;
    end
end

% Capsize: real eigenvalue with smallest magnitude real part
capsize = NaN;
if ~isempty(real_idx)
    [~, idx_min] = min(abs(real_parts(real_idx)));
    capsize = lam(real_idx(idx_min));
    assigned_idx(end+1) = real_idx(idx_min); %#ok<AGROW>
    real_idx(idx_min) = [];
end

% Remaining real eigenvalue -> caster
caster = NaN;
if ~isempty(real_idx)
    caster = lam(real_idx(1));
    assigned_idx(end+1) = real_idx(1); %#ok<AGROW>
    real_idx(1) = [];
end

lam_sorted = [wobble; weave; capsize; caster];

% Replace missing entries with sorted leftovers to preserve all eigenvalues
if any(isnan(lam_sorted))
    leftover = setdiff(1:numel(lam), unique(assigned_idx));
    for k = 1:numel(lam_sorted)
        if isnan(lam_sorted(k)) && ~isempty(leftover)
            lam_sorted(k) = lam(leftover(1));
            leftover(1) = [];
        end
    end
end

% If caster remains NaN but there are still unassigned, take one
if isnan(lam_sorted(4))
    leftover = setdiff(1:numel(lam), unique(assigned_idx));
    if ~isempty(leftover)
        lam_sorted(4) = lam(leftover(1));
    else
        lam_sorted(4) = lam(1);
    end
end
end
